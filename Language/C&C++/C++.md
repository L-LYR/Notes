# C++学习日记

## `namespace`

个人理解为在C语言的变量作用域的基础上，来创建一个单独为了声明名称的区域。

要点：

1. 不同名称空间的名称不会发生冲突。
2. 名称空间的定义可以嵌套，但不能出现在代码块内。
3. `using`指令：
   1. 将特定的名称添加到当前区域中。（不可以同时引入相同而来自不同名称空间的两个名称）
   2. 将名称空间引入当前区域中。

## 动态内存管理

下面给出几个有关动态分配内存的例子，其思想和C语言下的`malloc`及`free`大同小异。

```c++
struct object{ double d; int i; };
char buffer[80];

// basic usage
object *sp1 = new object; 			// create a struct object in heap

// initialization C++98
char *cp = new char ('A');

// initialization C++11
int *ip1 = new int(1);
int *ip2 = new int{1};
char *cpa = new char[4]{'a', 'b', 67, 85};
object *sp2 = new object{6.666, 666};

// placement
int *ip3 = new (buffer) int[10]; 	// create an int array in buffer
									// no need to use delete []
```

要点：

1. 严防内存泄漏，除非设计必要。
2. `new`失败后，引发异常`std::bad_alloc`。
3. `new`与`void operator new(std::size_t)`、`delete`、`void operator delete(void *)`对应；`new[]`与`void operator new[](std::size_t)`、`delete[]`、`void operator delete[](void *)`对应。
4. 针对类而言，如果有多个构造函数，且都要使用`new`来分配内存，一定要统一内存分配方式，因为只有一个析构函数与之匹配。
5. 应该为类设计深拷贝复制构造函数，重载深拷贝赋值运算符（包含检查自我复制，释放之前分配的内存，深拷贝等一系列操作）。

## 内联函数

要点不多，个人认为是宏的一种扩展与优化：

1. 内联函数的实质是编译器使用相应的函数代码块替换函数调用。这一点与宏类似，但与宏不同的是，内联函数和常规函数一样拥有传参的特性，而非简单替换。
2. 内联函数不能进行递归。
3. 使用方法是在函数声明和定义前添加关键字`inline`：
```c++
inline int add(int a, int b);

inline int add(int a, int b){ return a + b; }
```

但考虑到内联函数是使用空间换时间的策略，过长的函数不建议添加该特性，因此我们定义的内联函数都很短小，进而习惯性将其声明省略，把整个定义放在本应该提供原型声明的地方。

```c++
inline int add(int a, int b) { return a + b; }
```

## 默认参数

默认参数指函数调用中省略实参时自动使用的参数值，有以下几点：

1. 在参数列表中添加默认参数时必须按照从右至左的顺序。

```c++
int func1(int a, int b = 1, int c);			// invalid
int func2(int a, int b, int c = 1);			// valid
int func3(int a = 1, int b = 1, int c = 1);	// valid
```

2. 默认参数的设置仅需在函数声明时添加。

## 左值引用

左值引用（下简称引用）是已定义的变量的别名，可以直接通过引用来对原变量进行操作，所以其主要用途在于函数的引用传参。

1. 引用传参：通过将引用变量作为参数，函数可以直接操作原始数据，而不是其副本。除却指针，函数可以通过这种方式对大型数据结构进行代价较小的方便的操作。如下交换参数函数与指针实现效果相同。

```c++
void swap(int& a, int& b){ 
   int t = a;
   a = b;
   b = t;
}
```

2. 引用变量必须在声明的时候同时给予初始化。

```c++
int var = 9;

int& var_reference1;		// invalid
int& var_reference2 = var;	// valid
```

3. 引用和`const`指针类似，将某一新的变量与之前的某个变量关联起来。

``` c++
int var = 8;
int * const var_pointer = &var;
int& var_reference = var;
```

4. 与按值传递的不同：

```c++
int varSquare(int a){
   a *= a;
   return a;
}
int refSquare(int& a){
   a *= a;
   return a;
}
int constRefSquare(const int& a){
   // invalid
   // a *= a;
   return a * a;
}

int a = 2;
varSquare(a);			// valid, a = 2, return 4
varSquare(2);			// valid, return 4
varSquare(a + 2);		// valid, return 16

refSquare(a);			// valid, a = 4, return 4
refSquare(2);			// invalid
refSquare(a + 2);		// invalid

constRefSquare(a);		// valid, original variable
short b = 2;
constRefSquare(b);		// valid, temporary variable
constRefSquare(2); 		// valid, temporary variable
constRefSquare(a + 2);	// valid, temporary variable
```

   针对`const`引用参数如果有如下两种情况：

- 实参类型正确，但不是左值。
- 实参类型不正确，但可以通过强制类型转换为正确类型，则会创建临时变量，临时变量仅存在于函数调用期间。

5. 传统返回机制与按值传递类似，前者计算return后的表达式的值，再将结果返回给调用函数，实质上是值的临时复制，存在两次复制开销。返回引用则是直接返回一个变量的别名，效率更高。

```c++
struct hugeStruct;
hugeStruct& returnRefOpt(hugeStruct& hs);
hugeStruct returnVarOpt(hugeStruct& hs);

hugeStruct hs;

hugeStruct dup1 = returnRefOpt(hs);	// duplicate directly
hugeStruct dup2 = returnVarOpt(hs);	// duplicate twice
returnRefOpt(hs) = dup1;			// valid
returnVarOpt(hs) = dup2;			// invalid
```

6. 返回引用时，不可以返回函数内部声明的临时变量。同时如果不希望使用`func() = var`这样较为模糊的写法，请返回`const`引用。

## 函数重载

函数重载可以理解为不同语境下的多义动词，因此函数重载便是同一函数针对不同的参数列表进行操作，其关键在于函数的参数列表，即函数签名（Function Signature）。要点如下：

1. 如果函数的参数数目和类型相同，同时排列顺序也相同，则函数签名相同。重载函数的前提便是函数签名不同，只要参数数目、类型、排列顺序中至少有一个不同则有函数签名不同。

2. 函数的返回类型不包括在函数签名内，因此仅返回类型不同的同名函数不构成重载。

```c++
int add(int x, int y);		// origin
long add(int x, int y);		// invalid
long add(long x, long y);	// valid
```

3. 函数匹配的顺序：首先进行精确匹配，若无匹配，则对参数进行强制类型转换后重新匹配，此时如果存在多个转换且匹配成功的情况则视为错误。如以下举例：

```c++
void print(long l, int w);		// 1
void print(int i, int w);		// 2
void print(double d, int w);	// 3
```

   因此有如下匹配：

```c++
print(999.0, 2);		// 3
print(999, 2);			// 2
print(999L,2);			// 1

unsigned int ui = 999;
print(ui, 2);			// ambiguous
// unsigned int can be converted to long or double
```

4. 函数匹配时，类型引用与类型本身视为相同参数，因此不能据此进行重载。

```c++
// invalid
void print(double x);
void print(double &x);
```

5. 函数匹配时，不会区分`const`与非`const`变量。

```C++
// respectively matches non-const pointer and const pointer
void func1_p(char* x);
void func1_p(const char* x);
// only matches non-const pointer
void func2_p(char* x);
// matches both non-const pointer and const pointer
void func3_cp(const char* x);
```

6. 重载只是一种语法特性，重载函数在经过编译器的名称修饰（name decoration）之后会形成多个不同名称的函数。

## 运算符重载

和函数重载一样，C++中一些特定的运算符也可以重载，扩展到用户自定义的类型。

要点：

1. 重载后的运算符必须有一个操作数是用户自定义类型，换句话说，不允许用户为标准类型重载运算符。
2. 使用运算符时不能违反原来的句法规则，二元就是二元不能变成一元。
3. 不能创建新的运算符，比如`oeprator@()`。
4. 不能重载`sizeof() . .* :: ?: typeid const_cast dynamic_cast reinterpret_cast static_cast`。
5. 只能重载为类成员函数`= () [] ->`。

## 类设计

### 设计

描述对象所需的数据以及描述用户与数据交互所需的操作。

### 访问控制

1. `private`：指定私有成员，如数据，不应属于公有接口的实现细节。
2. `public`：指定公有成员，如公有接口。
3. `protected`：详见类继承。
4. `::`：作用域解析运算符，定义成员函数时使用。

### 构造函数

因为访问控制的限制下，一个类的私有数据部分是不可以被直接访问的，因此我们应该为类设计一种成员函数来完成这样的任务，这就是类构造函数。

要点：

1. 构造函数名称和类名相同，但构造函数的参数不应和类成员相同。（尽量将类成员统一添加前缀或后缀来区分）。

2. 使用方法有两种，显式调用构造函数与隐式调用构造函数。

```c++
class book{
string name_;
public:
   book(const string& name){ name_ = name; }
};
book abook = book("Animal Farm");			// 1
book bbook("C++Primer");				    // 2
```

3. C++11中列表初始化可以被用于对象的初始化，只要提供与某个构造函数的参数列表相匹配的内容即可。

4. 初始化列表语法，只有构造函数可以使用，而且对于`const`成员以及引用成员必须使用这种语法初始化。另外C++11允许更直观的类内初始化。

```c++
class book{
   int id_;
string name_;
public:
    book(const string& name,int id): name_(name), id_(id) {}
};

class people{
   int age_ = 0;
   double len_ = 0.0;

   ...
}
```

5. 列表初始化的顺序和列表内的顺序不同，而与数据成员被声明的顺序相同，因此当列表初始化中使用一个数据成员的值来初始化另一个数据成员时需要考虑这种顺序先后关系。

```c++
class book {
	string _author[80];
    string _buyer[80];
public:
    book(const string& auther) : _auther(auther), _buyer(_auther) {}
}
```

### 析构函数

用构造函数创建对象之后，程序会跟踪该对象，直至过期，这时候就轮到析构函数进行清理工作。

要点：

1. 当对象的构造函数中没有使用`new`来分配内存，那我们大可不必显式地去定义一个析构函数，只需让编译器为其生成一个隐式的即可。
2. 析构函数名称为类名前加`~`，没有返回值和参数，也就是说析构函数必须是这样的`~book()`。
3. 通常不应该在代码中显式地调用析构函数（存在例外），只要不是动态分配的对象，系统会在对象作用域结束之后自动调用。

### `const`成员函数

被`const`限定过的对象的数据成员是只读的，而有些成员函数无法确保调用对象不被修改，因此`const`对象不能够调用他们，这时我们需要针对`const`对象修改或者添加适合他们的版本，方法便是在已知不可能修改对象的函数声明和定义之后添加`const`限定。

### `static`成员函数

1. 不能通过对象调用静态成员函数，该函数内部不能使用`this`指针。如果访问权限是`public`则只能使用类名和作用域解析运算符来调用他。
2. 只能使用静态数据成员。

### 特殊成员函数

在没有给出定义的情况下，C++会默认提供以下函数：

#### 默认构造函数

默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。当一个类没有被提供任何构造函数时，编译器将自动提供默认构造函数（该函数不做任何工作，隐式调用时不需要括号）。一种可能的情况是个空函数`book::book() { }`。所以想要创建对象却不想显式地初始化，则必须定义一个不接受任何参数的默认构造函数，一是可以给已有的构造函数提供默认值，二是通过函数重载来定义另一个没有参数的构造函数，注意不要同时采取这两种方式。

#### 默认析构函数

类似地，默认析构函数可能是一个空的析构函数`book::~book() { }`。

#### 复制构造函数

```c++
ClassName(const ClassName &);
```

何时调用?有如下四种显式情况：

  ```c++
myStr str1(aStr);
myStr str2 = aStr;
myStr str3 = myStr(aStr);
myStr *str4 = new myStr(aStr);
  ```

每当程序生成了对象副本时，编译器都将使用复制构造函数。具体来讲，函数按值传递对象或函数返回对象时，都将调用复制构造函数。

默认复制构造函数的功能：逐个复制非静态成员（浅复制，复制值）（若成员也是类对象，则将调用那个类的复制构造函数）。

```c++
class example {int i; double *d;}
example a = b;

a.i = b.i;
a.d = b.d;
```

注意，这里将出现一种恶心的问题，类对象是个指针，这里仅仅只是给予地址，这样会存在内存的错误释放以及反复释放。解决方法是，显式地定义一个深复制的默认复制构造函数。适用于类中包含`new`初始化的指针成员。

#### 赋值运算符

```C++
ClassName & ClassName::operator=(const ClassName &);
```

将一个已有的对象赋值给另一个已声明对象时将使用赋值运算符，但要注意到初始化时并不一定会用到。

和复制构造函数相同，默认重载赋值运算符也仅仅是对对象的浅复制。所以也会产生上述问题，解决方法也是类似的，但有以下不同：

1. 由于被赋值对象在此之前有内存分配，因此要释放。
2. 该函数应避免将对象赋给自身，因为再赋给自己之前，内容可能已经被释放，所以最好在开头添加判断语句。
3. 函数应当返回一个指向调用对象的引用，以确保连续赋值的正确性。

#### 地址运算符

#### 移动构造函数（C++11）

#### 移动赋值运算符（C++11）

### `static`数据成员

要点：

1. 无论创建了多少个类对象，这里都只有一个静态数据成员副本。
2. 单纯的`static`数据成员不可以类内初始化，除非受到`const`限定。
3. 初始化应放在类方法定义文件中。

### `this`指针

当一个类成员函数使用时涉及不止一个对象时便需要使用`this`指针。

要点：

1. 每一个成员函数都有一个`this`指针，指向调用对象。
2. 对于`const`成员函数，`this`指针也被`const`限定。

### 类作用域

在类中定义的名称的作用域为整个类，在类外是不可知的。

在类内定义常量的方法：

1. 定义一个枚举`enum`。新特性：作用域内枚举。
2. 使用`static`来定义常量。它将会被所有对象共享。

### 作用域内枚举

这是C++11中添加的特性，因为之前的C语言枚举可能存在多个枚举中出现重复和冲突。

```c++
enum class egg {small, medium, large, jumbo};
enum struct clothes {small, medium, large, jumbo};

egg anEgg = egg::small;
clothes aTShirt = clothes::medium;
```

要点：

1. 作用域内枚举不能像普通枚举一样在表达式中被隐式地转换为整形，必须使用强制类型转换。
2. 作用域内枚举可以现式指定底层依赖类型，如`enum class : short pizza {small, big}`。

### 嵌套类

类声明可以放在另一个类中，通过提供新的类型类作用域来避免名称混乱。嵌套类如果是私有的，那么只有它处在的类可以使用它；如果是保护的，那么只有它处在的类和派生类可以使用；如果是公有的，那么都可以使用，在外界使用的时候需要加作用域解析运算符。

### 自动转换和强制类型转换

针对标准类型，C++的自动转换是兼容的条件下隐式进行的，比如从`char`到`int`。无法自动转换时，C++允许用户显式地使用强制类型转换，比如从`int`到`int*`。因此针对用户自定义的类型而言，也存在这种自动转换。

如果类中定义有一个参数的构造函数（可以含有默认参数），则赋值语句可以写成常见的赋值语句形式：

```C++
class weight{
	double w_;
    weight(double w);
}

weight aStone = 19.6;
```

这里将会隐式地调用`weight(19.6)`来构造一个临时对象，并将它赋给`aStone`。存在隐式转换的情形时，编译器便会调用该函数，如传参，返回值，初始化，赋值。

这里如果认为该种特性将会出现错误，则可以在声明时在函数之前添加`explicit`来关闭这种特性，但仍允许显式地进行强制类型转换：

```C++
weight anotherStone = weight(19.7);
anotherStone = (weight) 19.7;// old form
```

到这里，有一种想法随之出现，上述的转换过程可否反过来？这里我们只需要重载强制类型转换运算符即可。

```c++
class weight{
	double w_;
	weight(double w);
	operator double() const;
}
```

这里我们称之为转换函数，它既可以像强制类型转换一样显式调用，也可以作为自动转换被隐式调用。

转换函数的限制：

1. 必须声明为类方法。
2. 不能指定返回类型。
3. 不能有参数。

要点：

1. 可以存在多个转换函数，但要注意此时隐式调用存在的二义性。
2. C++98并不支持`explicit`作用于转换函数，但C++11解除了该限制，这样仅仅只能显式地调用转换函数，这样可以避免一些错误，同时消解多个转换函数并存的二义性。

## 友元

只能使用公有类方法访问私有部分，这个限制过于严格，所以提供了另外一种形式，这边是友元。友元也分三种：友元类，友元函数，友元成员函数。要使用到的关键字是`friend`。

### 友元函数

友元函数解决的问题在于类似的如下情形：

```c++
class A;
int operator*(int);

int B = A * 3;
int C = 3 * A; 	// how to ?
```

友元函数便可以解决上述问题，只需要声明并定义（定义不需要添加`friend`）：

```c++
friend int operator*(int, const A&);
```

这里要注意，他不是成员函数但和成员函数的访问权限相同。

一个类的成员函数可以是另一个类的友元函数。如果一个函数需要访问两个类的私有部分，那么最好声明为两个类的友元，而不是一个类的成员以及另一个类的友元。



### 友元类

一个类的友元类可以访问该类的私有部分。



## 函数模板

函数模板是通用的函数描述，即使用泛型来定义函数，其中泛型可以被具体的类型来替换。定义方法如下，其中`typename`是C++98添加的关键字。

```c++
template<typename AnyType>
void Swap(AnyType l, AnyType r) {...}

template<class AnyType>
void Swap(AnyType l, AnyType r) {...}
```

要点如下：

1. 函数模板不会出现在最终的代码中，而只会包含编译器根据模板而为实际情况生成的函数。一般来说，都将模板定义在头文件中，需要时包含即可。
2. 函数模板可以被重载，其函数签名必须不同。

### 显式具体化

- C++98标准：
  - 对于给定的函数名，可以有非模板函数，模板函数和显式具体化模板函数以及他们的重载版本。
  - 显式具体化的原型和定义以`template<>`开头，并通过名称来指定类型。
  - 显式具体化优先于常规模板，非模板优先于显式具体化和常规模板。

简单来说，抽象程度：模板$>$显式具体化$>$非模板，优先级：模板$<$显式具体化$<$非模板。

```c++
// non template
int add(int &a, int &b) { return a + b; };

// template prototype
template<typename T>
T add(T a, T b) { return a + b; };

// explicit specialization
template<> T add<long> (long a, long b) { return a + b; };
```

### 实例化

模板只是一个生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例。

```c++
// template prototype
template<typename T>
T add(T a, T b) { return a + b; };

// explicit instantiation I
template long long func<long long> (long long, long long);

// explicit instantiation II
...
int i = 6; // cast
double d = 6.5;
cout << add<double>(i, d) << endl;
...

// implicit instantiation
...
char a, b;
func(a, b);
...
```

显式实例化的意义在于告诉编译器使用模板声明一个某一类型的函数定义，而显式具体化则是告诉编译器不要使用模板声明某一个类型的函数定义，因为在后面将会给出针对该类型的专门函数定义。

注意在同一文件或者同一编译单元使用同一中类型的显示实例化和显示具体化将会出错。

### 重载解析

1. 创建候选函数列表，包含与被调函数名称相同的函数和模板函数。（只考虑函数签名）

```c++
void f(int);							//1
float f(float,float = 3);				//2
void f(char);							//3
char *f(const char *);					//4
char f(const char &);					//5
template<typename T> void *f(const T &);//6
template<typename T> void f(T *);		//7
```

2. 使用候选函数列表创建可行函数列表（参数数目相同），进而有一个隐式转换序列，包含实参与形参相同的情形。

```c++
f('A');
// 1 2 3 5 6 chosen
// 1 > 2
// 3, 5, 6 > 1
// 3, 5 > 6
// 3，5 => error
```

3. 确定是否有最佳的可行函数，存在多个可能的匹配以及不存在最佳的匹配都会导致编译器报错。

   - 确定优先级：完全匹配$>$整数提升$>$类型提升$>$用户自定义转换。
   - 前面提到的优先级：模板$<$显式具体化$<$非模板。
   - 参数优先级顺序：指向`const`数据的指针和引用优先于非`const`指针和引用。
   - 参数执行的提升转换越少，优先级越高，同时需要注意一些无关紧要的转换，如：类型与引用，数组名至指针，函数名至函数指针，类型至`const`和`volatile`。这些都是允许的转换。

### `decltype`

关键字`decltype`是C++11新增的关键字，用以解决模板定义中类型不明确的情况，如下：

```c++
template<typename T1, typename T2>
void f(T1 x, T2 y){ ? z = x + y; }		// unknown type of z

template<typename T1, typename T2>
? f(T1 x, T2 y){ return x + y; }		// unknown type of (x + y)
```

使用方法：

```c++
decltype(expression) variable;
```

1. `expression`是一个没有用括号括起来的标识符，则`variable`的类型与之相同（包含限定符）。
2. `expression`是一个函数调用（不会真正调用函数），则`variable`的类型是函数的返回值。
3. `expression`是一个左值或者是被括号括起来的标识符，则`variable`的类型是该类型的引用。
4. 除去上述情况，`variable`的类型和`expression`类型相同。

解决上述问题：

```c++
template<typename T1, typename T2>
void f(T1 x, T2 y){ decltype(x + y) z = x + y; }		

template<typename T1, typename T2>
void f(T1 x, T2 y){ 
    typedef decltype(x + y) xpy;
    xpy z = x + y; 
}		

template<typename T1, typename T2>
auto f(T1 x, T2 y) -> decltype(x + y) { return x + y; }
```

## 类继承

### is-a关系---公有继承

1. 从一个类派生出另一个类时，原始类叫做基类，继承类叫做派生类。

2. 派生类继承了基类的实现和接口。
3. 构造函数默认不能被继承。派生类需要自己的构造函数，可以根据需要添加额外的数据成员和成员函数。派生类的构造函数应当先创建基类对象，通过成员初始化列表将基类信息传递给基类构造函数，接着初始化派生类新增数据成员。
4. 析构函数不能被继承，这是出于内存管理的需要。
5. 赋值运算符不能被继承，因为他的形参的问题，该形参应当是其所属类。派生类对象赋值给基类，很正常，这会调用基类的赋值运算，操作只涉及基类成员；反过来，则需要显式定义转换构造函数或者重载赋值运算符。
6. 派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问，同样的，派生类只能使用基类的非私有方法。
7. 派生类如果不是一种特殊的基类，就不要使用公有派生，因为特殊化时is-a关系的原则。
8. 抽象基类是一种表示is-a关系的方法。
9. 无需进行显示类型转换是表示is-a关系的方式，基类指针可以在不进行显示类型转换的情况下指向派生类对象，基类引用可以在不进行显示类型转换的情况下引用派生类对象，但基类指针或引用只能调用基类方法。

### `virtual`

虚函数是指一个类中你希望重载的成员函数，当你用一个基类指针或引用指向一个继承类对象的时候，调用一个虚函数时，实际调用的是继承类的版本。

要点：

1. 构造函数不能是虚函数，同时构造函数是虚函数没有任何意义。
2. 析构函数必须是虚函数。
3. 友元不能是虚函数，因为他本来就不是类成员。
4. 如果派生类没有重定义基类中的虚函数，则将使用基类中的虚函数。
5. 如果基类中的虚函数重载了，那么在派生类中如果需要重新定义继承的虚函数，则应保持原型的不变性，同时最好重新定义所有版本，因为重定义操作将会隐藏基类中的所有版本。

### 动态联编和静态联编

将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编。C语言中很简单，因为函数名是唯一的，但C++引入多态后就很麻烦了，不仅需要查看函数名，还要看参数，这种能够在编译过程中完成这种联编叫做静态联编。虚函数的引入又提高了难度，因为针对虚函数而言使用哪个函数是不能在编译过程中确定的。（简单的例子，基类指针可以指向基类或者派生类，这是运行时才能确定的，他调用一个二者均提供定义的函数，我们无法在编译过程中确定他到底调用的是哪个）因此这就要求编译器生成能够在程序运行时选择正确虚函数的代码，这就是动态联编。换句话说，动态联编支持了基类和派生类之间指针和引用的兼容性。

要点：

1. 毋庸置疑，静态联编性能和效率更高。
2. 虚函数工作原理：每个对象中加一个隐藏成员，隐藏成员中保存了一个指向函数指针数组的指针，他被称作虚函数表，调用函数的时候查表比对即可。因此虚函数的使用成本：每个对象都变大了一点点，每个类都得分配一个虚函数地址表，每次调用虚函数都要查表。

### 访问控制`protected`

针对基类，`protected`控制与`private`一样，类外只能通过公有成员访问这两个部分的类成员。针对派生类，他不能直接访问基类的`private`成员，但可以直接访问基类的`protected`成员。

### 抽象基类

在一个虚函数的声明语句的分号前加上`=0`就可以将一个虚函数变成纯虚函数，其中，`=0`只能出现在类内部的虚函数声明语句处。纯虚函数只用声明，而不用定义，其存在就是为了提供接口，含有纯虚函数的类是抽象基类。我们不能直接创建一个抽象基类的对象，但可以创建其指针或者引用。值得注意的是，你也可以为纯虚函数提供定义，不过函数体必须定义在类的外部，但此时哪怕在外部定义了，也是纯虚函数，不能构建对象，所以没什么用。

抽象基类的存在意义是要求具体派生类覆盖其纯虚函数，迫使派生类遵循抽象基类设置的接口规则。

### 继承中的动态内存分配

如果派生类不需要`new`，而基类需要，我们只需要将基类的内存管理做好即可，无需管理派生类，不需要显式地定义析构函数、复制构造函数和赋值运算符。

如果派生类需要`new`，这时我们要处理好派生类和基类的内存管理，要显式地定义析构函数、复制构造函数和赋值运算符，同时要在其中调用（无论显式或者隐式）基类的相应函数。

### 友元与继承

友元与继承，我认为是一种垂直关系，友元关系不能随继承进行传递，基类的友元在访问派生类成员时不具备特殊性，派生类的友元也不能随意访问基类成员。

### has-a关系---包含对象&私有继承

has-a关系的表示方法很简单，有一种方法是将设计的类中包含想要的类对象即可，这里只继承了所包含类的实现，但无法获取其接口。

另一种方法是私有继承，私有继承会使得基类的所有成员全部成为派生类的私有成员，因此派生类不继承基类的接口，这正是has-a关系的一部分。

私有继承中就不能用成员名称来表示成员了，因为是不可见的，所以只能用类名和作用域解析运算符来调用基类方法，用强制类型转换来访问内部对象。这里如果嫌麻烦，可以用`using`来重新定义访问权限（派生类内）。

区别：

1. 前者更容易理解
2. 后者的问题更多，需要考虑的方面更多
3. 如果要包含多个同类子对象，那么需要用包含对象的方法，后者只能继承并使用一个
4. 如果子对象含有`protected`成员，那么私有继承便可以使用上述方法进行调用或者访问，但包含对象则归属于继承关系之外，因此无法访问。
5. 如果需要重新定义虚函数，则应使用私有继承，前者是不可以的。

### 保护继承

保护继承是私有继承的变体，基类的公有成员和保护成员均变为派生类的保护成员，他与私有继承的区别要看第三代，使用私有继承时，第三代不能使用第一代的接口，因为第一代的公有方法在第二代中被设置为私有，而使用保护继承时，第一代中的公有方法和保护方法将会变成第二代的保护方法，因此可以在第三代中被使用。

### 多重继承

私有或保护多重继承可以表示has-a关系，公有多重继承有如下一些问题：

1. 每一个公有继承都要写`public`，不然编译器默认为私有继承。
2. 多个基类拥有同名方法，这种是函数调用的二义性。所以这里要加作用域解析运算符，但这里设计要很精细，如果采用继承递增的方式设计，则会导致第三代功能调用重复，所以要尽量采用模块化的方式设计，或者不适用私有成员，而将所有继承链上的数据成员全部声明为保护成员，这样就可以直接访问数据成员而不会重复调用方法。
3. 第三代公有继承的第二代中存在多个派生于同一第一代，则使用第一代指针访问第三代时指向模糊，这种是多态指针的指向二义性。一种解决办法是使用强制类型转换来指定这个指针是指向哪一个第二代继承的第一代。另一种方法是使用虚基类。

### 虚基类

通过在类声明中添加`virtual`关键字来声明虚基类，虚基类可以使多个基类相同的类派生出的对象只继承一个基类对象。因为虚基类在第三代中只被继承了一个，所以第三代的构造函数如果还调用多个第二代的构造函数，这回导致问题，因此第三代构造的时候就只需要将参数直接传递给第一代的虚基类构造函数中即可，这里的访问是合法的，且只能这样做，不然则使用虚基类的默认构造函数。

## 类模板

定义方法与函数模板类似，也是使用关键字`class`和`typename`写在类外。

模板不是函数，因此不能单独编译，必须与特定的实例化请求一起使用，所以要将模板的所有信息放在一起，并在要使用的文件中引用模板头文件。

### 模板参数

模板类型参数可以递归使用，即类型参数也可以是模板。模板类型参数可设置默认参数。模板除了类型参数，也可传入表达式参数，但只能是整型、枚举、引用、指针。

### 实例化与具体化

类模板的隐式实例化、显式实例化和显式具体化和函数模板差不多。一样的用。

类模板有部分具体化的特性，针对多个类型参数，可以只提供部分参数或者提供指针，在编译过程中，编译器会自行选择具体化程度最高的模板。

### 模板成员

类成员可以直接定义模板并实例化，类内类外皆可，类外注意嵌套关系，怎么写都很麻烦。

### 模板与友元

1. 非模板友元，这种友元将成为所有模板实例的友元。他可以有类模板参数也可以没有，注意，他不是模板函数。
2. 约束模板友元，友元的模板类型将取决于模板实例化时的类型。他必须首先在类模板定义前给出模板声明，然后在类模板中声明为友元，并根据类模板的类型参数进行实例化，注意，他是模板函数。
3. 非约束模板友元，友元的所有具体化都是类的每一个具体化的友元，也就是说，他的参数类型不在类模板实例化时决定，而在调用传参时决定。他在类模板定义中给出模板声明，注意区分友元模板函数类型参数和类模板类型参数，他们是不同的，再注意，他也是模板函数。

### 类模板别名

给类模板提供别名可以使用`typedef`，C++11规定了`using `也可以这样用，还可以设置模板别名，即将模板部分具体化，减少参数。除了模板，`using`也可作用于非模板。

## 异常

### C的异常处理

`about()`位于头文件`cstdlib`，向标准错误流发送程序异常终止消息并终止程序，返回一个因实现而异的错误值，是否刷新文件缓冲区也是因实现而异。`exit()`也是类似的功能，但是没有输出消息，而且一定刷新文件缓冲区。返回错误码是不终止程序而反馈问题的方式，比如函数返回值或者函数的附加参数。

### 异常机制

`throw`关键字表示引发异常，之后跟一个说明异常特征的值，最好是一个对象，这样承载的信息量更多。

`try`标识块表示其中特定异常可能被触发的的代码块，之后跟着一个或多个`catch`块。

`catch`块表示处理异常，括号的内容表示异常特征的值（最好是基类对象引用），指明类型，之后的代码块为异常处理程序。