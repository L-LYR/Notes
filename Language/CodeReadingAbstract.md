# 2019.2.3

- STREQ宏 由于strcmp()的返回值并不直观 该宏是为了使得两个字符串相等时能返回true,同时利用首字符提高效率。如下：

  ```c
  #define STREQ(a,b) (*(a)==*(b) && strcmp((a),(b)) == 0)
  ```

- 输出函数的失败原因（尤其是在程序的标准输出被重定向至文件时）

  - 存储输出的设备可能没有剩余空间
  - 设备上用户的空间配额可能已耗尽
  - 进程可能试图向某个文件写入超出进程或系统文件最大尺寸限制的数据
  - 输出设备上可能发生硬件错误
  - 文件描述符与标准输出相关联的流可能无法有效写入

  解决方案

  Java----checkError方法

  C++----fail、good或bad方法

  C----ferror()函数

  ``` c
  if(ferror(stdout))
  	err(1,"stdout");
  ```

- 在审查代码时，最好确保所有只用于单个文件的变量和函数都声明为static

- 了解一个函数或方法

  - 根据函数名猜测
  - 阅读函数开头的注释
  - 分析函数是怎么被使用的
  - 阅读函数体内的代码块
  - 查询外部程序文档

- switch语句用于处理大量离散的整型和字符型的值。注意break，return语句以及default标记的存在与否。如果要合并，则最好加注释`/*FALLTHROUGH*/`。最好还是要写default的，这是良好的保护性编程实践，是用来捕获产生意外值的程序错误并提醒维护者。

  ```c
  switch(variable)
  {
      case value_1:
          break;
      case value_2:
          break;
      default:
          printf("Internal error!");//或者是其他的报错方法
          break;
  }
  ```

- 对于for()循环，时刻注意其循环次数。

- 多数情况下，无限循环用来表达在循环开始或结束时退出条件无法确定的循环，这些循环通常或者通过return语句退出当前函数，或者通过break语句退出当前循环体，亦或调用exit或类似的函数退出整个程序。C++，C#和Java还可以通过异常来退出这类循环。

- 请注意，continue会忽略switch语句，另外break和continue都不会影响if语句的操作。同时，continue常被用作占位符(placeholder)，即循环中不需要操作的空语句写成`continue;`

- 尽管高效的算法和某些优化确实会使代码变得复杂和难以理解，但这并不意味着让代码复杂和难以理解会使代码更有效率。在没有必要为了代码效率而牺牲可读性的地方不要乱改乱缩减。有时，创造性的布局可用来提高代码的可读性。方法有，添加空格、利用临时变量将表达式分解成较小的部分、使用小括号增强特定运算符的优先次序。同时，一些不影响程序运行的项（例如：注释、空白，以及对于变量、函数和类的名称的选择）常常会影响程序的可读性。

- 大神写成这样叫技术，你写成这样叫垃圾。

  ```  c
  #include <stdio.h>
  char *a;
  main(int t, int _, char *a)
  {
      return !0 < t ? t < 3 ? main(-79, -13, a + main(-87, 1 - _, main(-86, 0, a + 1) + a)) : 1, t < _ ? main(t + 1, _, a) : 3, main(-94, -27 + t, a) && t == 2 ? _ < 13 ? main(2, _ + 1, "%s %d %d\n") : 9 : 16 : t < 0 ? t < -72 ? main(_, t, "@n'+,#'/*{}w+/w#cdnr/+,{}r/*de}+,/*{*+,/w{%+,/w#q#n+,/#{l+,/n{n+,/+#n+,/#;#q#n+,/+k#;*+,/'r :'d*'3,}{w+K w'K:'+}e#';dq#'l q#'+d'K#!/+k#;q#'r}eKK#}w'r}eKK{nl]'/#;#q#n'){)#}w'){){nl]'/+#n';d}rw' i;# ){nl]!/n{n#'; r{#w'r nc{nl]'/#{l,+'K {rw' iK{;[{nl]'/w#q#n'wk nw' iwk{KK{nl]!/w{%'l##w#' i; :{nl]'/*{q#'ld;r'}{nlwb!/*de}'c ;;{nl'-{}rw]'/+,}##'*}#nc,',#nw]'/+kd'+e}+;#'rdq#w! nr'/ ') }+}{rl#'{n' ')# }'+}##(!!/") : t < -50 ? _ == *a ? putchar(31 [a]) : main(-65, _, a + 1) : main((*a == '/') + t, _, a + 1) : 0 < t ? main(2, 2, "%s") : *a == '/' || main(0, main(-61, *a, "!ek;dc i@bK'(q)-[w]*%n+r3#l,{}:\nuwloca-O;m .vpbks,fxntdCeghiry"), a + 1);
  }
  ```
# 2019.2.4

- goto语句在嵌套循环和switch语句中改变程序的控制流程，在大型复杂循环中采用这种做法可以阐明控制流程的走向，同时避免在嵌套循环中添加特定的break或continue语句引起错误的可能性。（break和continue只能影响最内层循环的控制流程）

- =与==的误用:

  - 如果真的要表示p赋给q同时判断q是否为0，则最好写为(q=p)==0，即在最外层加一个括号，而不是写为q=p，这样表意清晰；

  - 所有与常量的比较都将常量写在比较表达式的左边，如：

    0 == variable;

- `a&b`等价于`a%(b+1)`,位运算更高效哦~


# 2019.2.5

- 循环不变式主要用来辅助我们理解算法的正确性，对于循环不变式，必须证明它的三个性质（类似于数学归纳法）：
  - 初始化：它在循环的第一轮迭代开始之前，是正确的。
  - 保持：如果在某一次循环迭代开始之前是正确的，那么在下一次迭代开始之前，它也应该保持正确（假设当循环变量等于k时符合，再看执行一遍循环体后是否还符合循环不变式）。
  - 结束：当循环结束时，不变式给了我们一个有用的性质，它表明算法是正确的（这一步是和数学归纳法不同的一点，用循环不变式则更进一步，数学归纳法到这里就得出了一个关系式就结束，而用循环不变式，不但要先确保一个正确的关系式，还要看最后循环结束时，循环变量最后等于多少，根据循环不变式推导是否符合自己的要求。）。

  编写循环时，找到让每次循环都成立的逻辑表达式很重要。这种逻辑表达式称为循环不变式（loop invariant）。循环不变式相当于数学归纳法的“断言”。循环不变式用于证明程序的正确性。在编写循环时，思考一下“这个循环的循环不变式是什么”就能减少错误。 
  注意：每个循环都可以找到一个循环不变式，并通过这个循环不变式证明循环迭代的正确性。

- 指针的常见用法
  - 创建链式数据结构
  - 引用动态分配的数据结构
  - 实现引用调用
  - 访问和遍历数据集合
  - 传递数组参数
  - 作为函数的引用
    - 将函数作为参数传递给另一个函数
  - 作为其他值的别名
    - 效率上的考虑（对指针的赋值更高效）
    - 引用静态初始化的数据
    - 访问和修改全局变量的值
  - 表示字符串
    - 这里要注意区分字符指针和字符数组的差别，其底层类型及可对其使用的操作是不同的，尽管在大多数情况下可以互换。
  - 直接访问系统内存
- 结构体的常见用法
  - 包含不同数据并将其作为整体使用

    - 比如说屏幕位置坐标、复数、表格等
  - 使函数可以返回多个结果
  - 创建链表类型的数据结构
  - 映射硬件设备、网络、存储介质上的数据组织方式
  - 实现抽象数据类型
  - 以面向对象的方式编写代码
    - C语言中会用结构体和相关的数据以及函数指针封装在一起，来模拟类的字段和方法，从而创建类似对象的实体，但是用起来很蛋疼。“对象”可以使用不同的“方法”（函数指针）来初始化，并且利用相同的借口调用（通过使用同一结构体成员名），这其实就是面向对象语言中实现虚函数和多态的做法。
    - 以下的例子中我们可以看到，每个对象表示一个打开的文件或者套接字（socket），通过包含指向fileops类型结构体的变量f_ops，对象之间共享了几种方法。

    - ``` c
      struct file{
      short f_type;
      short f_count;
      short f_msgcount;
      struct ucred *f_cred;
      struct fileops{
        int (*fo_read)  (struct file*fp,struct uio*uio,struct ucred*cred);
        int (*fo_write) (struct file*fp,struct uio*uio,struct ucred*cred);
        int (*fo_ioctl) (struct file*fp,u_long com,caddrt_t data,struct proc*p);
        int (*fo_poll)  (struct file*fp,int events,struct proc*p);
        int (*fo_close) (struct file*fp,struct proc*p);
      } f*ops;
      off_t f_offset;
      caddr_t f_data;
      }
      ```
      

- 联合体的常见用法

  - 有效利用存储空间

    - 嵌入式设备

  - 实现多态

    - 多态在这里是指同一个对象表示多种类型

    - 以下是RPC库中的一段代码

    - ```c
      enum msg_type{
      	CALL=0;
      	REPLAY=1;
      };
      struct rpc_msg{
          u_int32_t rm_xid;
          enum msg_type rm_direction;
          union{
              struct call_body RM_cmb;
              struct reply_body RM_cmb;
          }ru;
      };
      ```

  - 使用内部表征方式访问数据

    - 表征的意思是信息的呈现方式，例如对于一个bit序列，它的表征可以是一个浮点数或者一个整数等。

    - 将数据存储在联合体的一个字段中，然后访问联合体的另一个字段，便可以做到数据在不同的内部表征之间的转换。

    - 以下这种用法可能会导致程序不可移植，因为有些实现取决于具体的机器。

    - ```c
      union{
          double v;//存储需要访问的浮点数变量
          struct{//通过该变量访问浮点数的内部表征
              u_int u_mant2:32;//尾数
              u_int u_mant1:20;
              u_int u_exp:11;//指数
              u_int u_sign:1;
          }s
      }
      ```

# 2019.2.6

- 动态内存分配
  - 空闲内存管理
    - 垃圾回收器：如果程序中分配的内存空间存在多个指针引用，手动释放内存将变得很困难，此时常常会用到这一技术。其工作原理是为每个分配的内存空间增加一个引用计数，一旦有新的指针指向着块内存空间，就将引用计数的值增加一，如果指向这块内存空间的某个指针被销毁，就将引用计数的值减一，如果引用计数的值为0，说明这块内存空间已经不再使用，此时就可以将其释放。
  - 包含动态分配数组的结构
- typedef声明

    - 一种抽象机制，提高代码可读性，创建便于移植的名称，创建抽象名称，模拟类。
- C数据结构
    - 向量-数组
        - 常见操作函数memset，memcpy和memmove，三者第三个参数都是要进行操作的`字节数`
        - 在使用memcpy时，复制多于目标数据大小的字节将产生一些难以预料的结果。
        - 同时，memcpy和memset都削弱了类型检查系统，需自行检查原参数和目标参数是否指向相同的数据类型。
        - memmove用于拷贝字节，如果目标区域和源区域有重叠的话，memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。当目标区域与源区域没有重叠则和memcpy函数功能相同。
        - 对于数组的操作要小心越界。

    - 矩阵和表
        - 矩阵中元素都是同一类型，表中元素大多数是不同类型。
        - 表一般用结构体数组来进行存储和处理，矩阵可以用二维数组或者显式代码（宏）来模拟访问。

    - 栈
        - 后进先出
        - 常用于算术表达式求值，（和递归定义一同用于）块结构编程和标记语言，数据类型，层次数据结构，程序执行，遍历和查找，图算法，处理中断，以及应用软件中撤销命令的实现。
        - 注意对上溢和下溢的检查

    - 队列
        - 先进先出
        - 用来管理两个系统不同的数据生成和特征处理。如窗口系统与应用软件的连接，操作系统对输入数据包的处理，以及邮件消息在MTA（适配器端）间的转发方式，对网卡、磁盘驱动器、串行通信设备和打印机的请求和产生数据的处理。
        - 循环队列（仅有单索引）利用条件表达式或取模运算实现，也有的使用头部索引和尾部索引来实现。

    - 哈希映射（hash map）

        - 可以理解为“链表的数组”。

    - 散列表（hash table）
        - 通过散列函数将数据转化成一个整数，并将计算得到的值限定在数组的合法索引范围内，然后进行存储。
        - 在定位至数组的某位置后，需要检查在该位置的元素是否为我们想要的元素，若有多个则应计算新的备选位置。

    - 集合（set）

        - 当希望高效表征和处理元素且这些元素是较小的整数时，常常将该集合表达为二进制数组，并将集合中的每个元素都基于特定的位（bit）。

        - C语言中一般使用某种整型作为底层储存元素，并且移位和逐位与或或的方法来处理特定的位

        - ```c
            pbitvec[j / BITS_PER_LONG] = ((undigned long)1 << (j % BITS_PER_LONG));
            
            #define FD_ISSET(n,p) \
            ((p)->fds_bits[(n)/NFDBITS] & (1 << ((n) % NFDBITS)))
            
            #define FD_CLR(n,p) \
            ((p)->fds_bits[(n)/NFDBITS] &= ~ (1 << ((n) % NFDBITS)))
            
            #define XFD_ANDSET(dst,b1,b2) \
            (dst)->fds_bits[0] = ((b1)->fds_bits[0] & (b2)->fds_bits[0]);\
            ```

        - 以上例子中pbitvec数组有长整型数组成，其中每个元素包含BITS_PER_LONG个二进制位。因此每个数组元素可存储BITS_PER_LONG个集合元素信息。因此可以使用集合元素编号j除以BITS_PER_LONG，从而找到数组中包含特定元素信息的位置，之后使用所得的余数对1（注意强制类型转换）左移位以便将其定位到存储特定元素信息的位。通过将已有的数组值与刚创造的掩码进行逐位或运算，数组中的该位被设定为1，意味着j成为了集合的成员。类似的，可以通过对已创建好的位和相应的数组元素之间进行逐位与运算来测试一个元素是否是集合中的成员。最后，可以通过对数组元素和构造的掩码进行逐位与运算，将一个元素从集合中移除。通常也可直接使用逐位与和逐位或合并数组元素来实现集合的合并和相交。

    - 链表

        - 高效增加和删除元素
        - 顺序访问

    - 树

        - 查找、排序、语言处理、图形和压缩算法、组织数据库文件、目录、设备内存体系、属性、网络路由、文档结构以及显示元素
        - 由于其递归定义，故适合采用递归算法。

    - 图

        - 节点存储

            - 将所有的节点存入数组或者链接为链表
        - 边的表示

            - 隐式地使用指针来表示
            - 显式地使用独立的数据结构来表示
        - 边的存储

            - 以数组的形式存于节点结构体中
            - 以链表的形式锚定在图节点上
        - 图的属性

            - 有向图和无向图
            - 连通图和非连通图以及包含回路的图
        - 隐含结构
            - 维护有多个表示边的结构
        - 其他表示方法
            - 二维数组（邻接矩阵）和邻接表（产品程序中少见，算法中常见，动态调整大小较为困难）

# 2019.2.7

至此，能看懂的，有用的都在这儿了。

