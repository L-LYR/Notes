# 汇编语言（80x86汇编）

## 基础概念

### 汇编语言的组成

1. 汇编指令：机器码的助记符，对应一定的机器码。
2. 伪指令：没有对应的机器码，由编译器执行，计算机不执行。
3. 其他符号：如`+`、`-`、`*`、`/`等，由编译器识别，没有对应机器码。

### 指令和数据

指令是对二进制信息的一种抽象。硬件层面二者均为二进制信息，只不过在工作状态下CPU为其赋予不同的意义。

### 硬件

- 脑子——CPU
- 记忆——存储器（RAM&ROM）
- 神经——总线（外部）
  1. 地址总线：发送地址信息，其宽度决定了CPU能够寻址的范围。
  2. 数据总线：交换内存数据，其宽度决定了CPU和外界的数据传输速度。
  3. 控制总线：由不同控制线组成，对外部器件进行控制，如发送读写命令。
- 脑壳——主板+接口

### 内存地址空间

对CPU来讲，系统中所有存储器中的存储单元全都被CPU抽象成一个统一的内存空间（一维线性空间），进行统一编号，每一个内存单元都有一个唯一的地址，称为物理地址。不同CPU由不同的物理地址生成方式。内存地址空间的大小由地址总线宽度限制，若宽度为$n$，则地址空间的范围为$0 \sim 2^n-1$。

以8086CPU为例，他具有20位宽的地址总线，寻址能力达1MB。而8086CPU是16位结构，因此他采用一种两个16位地址合成20位物理地址的方法。首先CPU提供两个十六位地址，段地址和偏移地址，通过内部总线传输到地址加法器。地址加法器将段地址低位添加4位0后与偏移地址相加获得物理地址。

### 段

虽说段地址给人一种内存被分段的感觉，但事实上不是这样的，而是内存被CPU分段管理罢了。段的最大长度由偏移地址的最大位宽决定，如8086CPU偏移地址16位，因此段的最大长度为64KB。

## 8086CPU的工作方式

### 实（地址）方式

在实地址方式下，可以使用32位寄存器和32位操作数，也可以采用32位寻址方式，但32位CPU只能与16位CPU一样，只能寻址1MB的物理存储空间，段基址和偏移地址都是16位的，程序段大小不能超过64KB。

### 保护方式

在保护方式下，使用32位地址线，寻址4GB的物理存储空间，虚拟存储空间可达64TB。段基址和偏移地址都是32位的，程序段大小可达4GB。

1. 功能：提供支持多任务的硬件结构，能为每一个任务提供一台虚拟处理器来仿真多台处理器。
2. 保护：利用分段和分页的存储管理功能对各个任务分配不同的虚拟存储空间，实施执行环境的隔离和保护，对不同的段设立特权级并进行访问权限检查，以防不同用户程序之间、用户程序与系统程序之间的非法访问和干扰破坏。

### 虚拟8086方式

在保护方式下运行类似实方式的工作环境，充分利用保护方式提供的多任务硬件结构、强大的存储管理和保护能力。

## 寄存器

CPU一般是由运算器、控制器、寄存器等器件构成，各个器件由（CPU）内部总线连接。针对汇编来说，主要部件的就是寄存器。以8086CPU为例，他具有十四个寄存器。

```asm
AX BX CX DX SI DI SP BP IP CS SS DS ES PSW
```

8086CPU的寄存器都是16位的，可以存放两个字节的数据。

### 通用寄存器`AX BX CX DX EAX EBX ECX EDX`

通常用来存放一般性的数据。因为上一代8080CPU中寄存器都是8位的，因此为了向前兼容，这些寄存器都可以拆成两个8位的寄存器来用，比如`AX`的高8位为`AH`，第8位为`AL`。以E开头的寄存器均为32位。

### 段寄存器`CS DS SS ES FS GS`

- 代码段寄存器`CS`：与`IP`连着用，例如对8086CPU来说`CS<<4+IP`是当前CPU将要取的一条指令的地址。
- 堆栈段寄存器`SS`：与`SP`连着用，任意时刻，`SS:SP`指向栈顶。
- 数据段寄存器`DS`：用来存放用户希望存放的一些数据。
- 附加段寄存器`ES`：存放当前执行程序中一个辅助数据段的段地址。

### 指令指针寄存器`IP`

同上`CS`描述，每次取完指令后`IP`将自增所读取的指令长度，从而指向下一条指令。

### 堆栈指针寄存器`SP/ESP`

同上`SS`描述，`SP/ESP`是用户建立的自己的字或双字堆栈的栈顶指针，其中存储着栈顶相对于`SS`的偏移地址。

## 寻址方式

### 立即寻址

一个立即数（常数或数值表达式）。

```asm
MOV BX,10
MOV AH,'A'
ADD EAX,-12345678H
```

要点：

1. 立即数只能作为双操作数指令的源操作数，不能作为目的操作数，不能作为单操作指令的操作数。
2. 立即数只有大小没有类型，占用的字节数由目的操作数决定。

### 寄存器寻址

指令所指明的寄存器`R`即是操作数的存放地址，即操作数在指令指明的寄存器`R`中。就像使用变量一样使用`R`即可。

```asm
;example 1
INC	BX
ADD	EAX,EDX
DEC CH
```

要点：

1. 寄存器既可以作源操作数也可以作目的操作数，操作数的类型由寄存器位数决定。

2. 双操作数指令中，当两个操作数的类型明确时，必须一致，以下为错误示范：

   ```asm
   MOV BL,AX
   MOV AX,EAX
   ```

### 直接寻址（跨段前缀）

操作数存放在主存储器（指定的段中），操作数的编译地址紧跟在指令操作码后面，存放在内存的代码段，构成指令的一部分，通过`IP/EIP`获取。格式：`S:[n]`、`v`、`v+n`。其中`S`为段寄存器，`n`为数值或数值表达式（无符号数），`v`为变量。

```asm
MOV DS:[20H],CL
INC BUF			;BUF为定义在附加数据段的字节类型变量
MOV AX,DS:BUF
SUB WORD PTR DS:[1000H],55AAH
```

要点：

1. `S:[n]`无类型，后两种格式类型由变量类型决定。
2. `S:[n]`中可以换成`v`。

### 寄存器间接寻址

操作数存储在主存储器中，而其偏移地址存储在指令指明的寄存器中。使用格式和C语言中数组下标类似，`[R]`。

```asm
MOV	AX,[SI]
MOV CX,[EBP]
```

要点：

1. 16位情况，`BX`，`BP`，`SI`，`DI`之一。

2. 32位情况，`EAX`、`EBX`、`ECX`、`EDX`、`EDI`、`ESI`、`EBP`、`ESP`之一。

3. 当`R`为`BP`、`EBP`、`ESP`时操作对象在堆栈段中，实际格式为`DS:(R)`，其余为数据段`DS:(R)`。

4. 显示情况下，可在之前加跨段前缀来改变默认段属性。如

   ```asm
   MOV DS:[EBP],CX
   ```

5. 无类型。但当类型不明确时，最好指出操作数类型。

### 变址寻址

操作数存储在主存储器中，而其偏移地址是指令中指定寄存器的内容乘以比例因子之后与给出的位移量之和。共三种格式：`[R*F+V]`、`[R*F]+V`、`V[R*F]`。

```asm
MOV	AL,[EBX*2]+5
ADD	-2[BP],AX
```

要点：

1. 其中`F`可以为1，2，4，8。
2. 16位情况，`BX`，`BP`，`SI`，`DI`之一。
3. 32位情况，`EAX`、`EBX`、`ECX`、`EDX`、`EDI`、`ESI`、`EBP`、`ESP`之一。
4. 当`R`为`BP`、`EBP`、`ESP`时操作对象在堆栈段中，实际格式为`SS:(R)`，其余为数据段`DS:(R)`。
5. 若无变量`V`则无类型，否则类型由变量决定。

### 基址加变址寻址

操作数存放在存储器中，其偏移地址是指令中指定的基址寄存器的内容，变址寄存器的内容乘以比例因子以及位移量的和。共三种格式：`[BR+IR*F+V]`、`[V[BR][IR*F]`、`V[BR+IR*F]`。

要点：

1. 其中`F`可以为1，2，4，8。
2. 16位情况下，基址寄存器只能使用`BX`和`BP`，变址寄存器只能使用`SI`和`DI`，`F`只能等于1；32位情况下，基址寄存器可以使用所有的32位通用寄存器，变址寄存器可以使用除`ESP`之外的32位通用寄存器。
3. 默认段寄存器由基址寄存器决定。`BR`为`BX`，`ESP`，`EBP`时，默认段寄存器为`SS`，其余均为`DS`。
4. 若无变量`V`则无类型，否则类型由变量决定。

```asm
MOV AX,8[BX][SI]
MOV EAX,-6[EDI*2][EBP]
```

5. 优先级：跨段前缀$>$变量$>$`BR`

## 指令

### `MOV`

```asm
MOV <opd1>,<opd2>
; opd1 can be register, memory address, segment register
; opd2 can be number, register, memory address
```

1. `MOV`不可以修改`CS`和`IP`的值。

### `ADD & SUB`

```asm
ADD <opd1>,<opd2>
SUB <opd1>,<opd2>
; opd1 can be register, memory address
; opd2 can be number, register, memory address
```

1. `ADD & SUB`的操作数不能是段寄存器。

### `JMP`

```asm
JMP <Segment Address>: <Offset Address>
JMP <Register>
```

### `PUSH & POP`

```asm
PUSH <opd>
POP <opd>
; opd can be register, segment register, memory address
```

1. 任意时刻，`SS:SP`指向栈顶。

2. 8086CPU不能保证用户对栈的操作不会超界，他只知道栈顶在哪。

### `LOOP`

```asm
LOOP <mark>
; mark is an address of a certain piece of code
```

1. CPU在执行`LOOP`时，步骤如下：
   1. `(CX)=(CX)-1`；
   2. 判断`(CX)==0`，等于0则执行下一条指令，否则跳转至标记处。